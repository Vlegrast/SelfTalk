<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Custom SelfTalk Chat</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Press Start 2P', cursive;
      background-color: #1e1e1e;
      color: #eee;
      max-width: 700px;
      margin: 40px auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 18px;
    }
    .chat-container {
      background-color: #2b2b2b;
      border: 2px solid #444;
      padding: 20px;
      height: 400px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      scroll-behavior: smooth;
    }
    .chat-message-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 70%;
    }
    .chat-message-container.left {
      align-self: flex-start;
    }
    .chat-message-container.right {
      align-self: flex-end;
    }
    .msg-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 10px;
      color: #ccc;
      user-select: none;
    }
    .avatar-header {
      font-size: 16px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      overflow: hidden;
      background-color: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .avatar-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
      display: block;
    }
    .name-header {
      font-weight: bold;
    }
    .time-header {
      margin-left: auto;
      font-style: italic;
      font-size: 9px;
      color: #999;
    }
    .bubble {
      max-width: 100%;
      padding: 10px;
      border-radius: 12px;
      word-wrap: break-word;
      position: relative;
      font-size: 12px;
      line-height: 1.3;
      display: flex;
      gap: 8px;
      align-items: center;
      cursor: pointer;
      transition: background-color 0.3s ease;
      white-space: pre-wrap;
      user-select: text;
    }
    .bubble.left {
      border-bottom-left-radius: 0;
    }
    .bubble.right {
      border-bottom-right-radius: 0;
    }
    textarea {
      width: 100%;
      height: 80px;
      margin-top: 10px;
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      resize: vertical;
      padding: 10px;
      border-radius: 6px;
      border: none;
      outline: none;
      transition: background-color 0.3s ease, color 0.3s ease;
      background-color: #2b2b2b; /* default white */
      color: #ccc;
    }
    .controls {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
      align-items: center;
    }
    input[type="text"] {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      padding: 10px;
      flex-grow: 1;
      min-width: 120px;
      border: none;
      border-radius: 6px;
    }
    input[type="color"] {
      cursor: pointer;
      border: none;
      padding: 0;
      width: 40px;
      height: 30px;
      border-radius: 6px;
      flex-shrink: 0;
    }
    button {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      padding: 10px 15px;
      background-color: #444;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 6px;
      white-space: nowrap;
      transition: background-color 0.3s ease;
      flex-shrink: 0;
    }
    button:hover {
      background-color: #666;
    }
    label {
      font-size: 12px;
      user-select: none;
      margin-bottom: 4px;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      min-width: 120px;
    }
    /* --- Character Circles --- */
    #characterCircles {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .char-circle {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      border: 2px solid transparent;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.3s ease;
      background-color: transparent;
    }
    .char-circle.selected {
      border-color: #fff;
    }
    /* ‚ñº ADD: Triangle above selected character */
    .char-circle.selected::before {
      content: '';
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
     width: 0;
     height: 0;
     border-left: 6px solid transparent;
     border-right: 6px solid transparent;
     border-bottom: 8px solid currentColor;
    }
    .char-avatar {
      font-size: 20px;
      user-select: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f0f0f0;
      color: #444;
      font-weight: bold;
    }
    .char-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
      display: block;
    }
    /* Side toggle circle button */
    #sideToggle {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: background-color 0.3s ease;
      background-color: #444;
    }
    #sideToggle.left::after {
      content: '‚¨ÖÔ∏è';
    }
    #sideToggle.right::after {
      content: '‚û°Ô∏è';
    }
    /* Avatar picker emoji list */
    #avatarPicker {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      max-width: 280px;
    }
    .emojiOption {
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      padding: 4px 8px;
      border-radius: 6px;
      transition: background-color 0.3s ease;
      background-color: transparent;
      color: #eee;
    }
    .emojiOption.selected {
      background-color: #4e9a06;
      color: white;
    }
    /* Upload avatar input hidden */
    #avatarFileInput {
      display: none;
    }
  </style>
</head>
<body>

<h1>SelfTalk - Chat</h1>

<div class="chat-container" id="chatContainer"></div>

<div class="controls">
  <div class="input-group">
    <label for="nameInput">Your Name:</label>
    <input 
    type="text" 
    id="nameInput" 
    placeholder="Enter your name or nickname" 
    onclick="if(this.value === 'Anon') this.value = ''; this.select();" 
    />
  </div>

  <div class="input-group">
    <label for="colorInput">Bubble Color:</label>
    <input type="color" id="colorInput" />
  </div>

  <button id="sideToggle" title="Toggle message side" class="right"></button>
  <button id="clearBtn" title="Clear all chat messages">Clear Chat</button>
</div>

<div id="avatarPicker">
  <span class="emojiOption">üôÇ</span>
  <span class="emojiOption">üòé</span>
  <span class="emojiOption">üò∫</span>
  <span class="emojiOption">üëª</span>
  <span class="emojiOption">ü§ñ</span>
  <span class="emojiOption">üê∂</span>
  <button id="uploadAvatarBtn" title="Upload avatar image">üì∑</button>
  <input type="file" id="avatarFileInput" accept="image/*" />
</div>

<textarea id="messageInput" placeholder="Type your message..."></textarea><br />
<button id="sendBtn">Send</button>

<div id="characterCircles"></div>
<div style="margin-top:10px;">
  <button id="addCharacterBtn">Add Character</button>
  <button id="deleteCharacterBtn">Delete Character</button>
  <button id="saveCharacterBtn">Save Character</button>
</div>

<script>

document.addEventListener('DOMContentLoaded', () => {
  const chatContainer = document.getElementById('chatContainer');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const clearBtn = document.getElementById('clearBtn');
  const nameInput = document.getElementById('nameInput');
  const colorInput = document.getElementById('colorInput');
  const sideToggle = document.getElementById('sideToggle');
  const avatarPicker = document.getElementById('avatarPicker');
  const uploadAvatarBtn = document.getElementById('uploadAvatarBtn');
  const avatarFileInput = document.getElementById('avatarFileInput');
  const characterCircles = document.getElementById('characterCircles');
  const addCharacterBtn = document.getElementById('addCharacterBtn');
  const deleteCharacterBtn = document.getElementById('deleteCharacterBtn');
  const saveCharacterBtn = document.getElementById('saveCharacterBtn'); // ‚Üê Add this line
  

  const MAX_CHARACTERS = 25;


  let chatData = JSON.parse(localStorage.getItem('chatData')) || [];
  let characters = JSON.parse(localStorage.getItem('characters')) || [];
 
  characters.forEach(char => {
  if (!char.id) {
    char.id = Date.now() + Math.random();
  }
});

  let currentCharacterIndex = -1;
  let currentAvatarEmoji = 'üôÇ';
  let currentAvatarImage = null;
  let currentSide = 'right';

  if (saveCharacterBtn) {
    saveCharacterBtn.addEventListener('click', () => { // ‚Üê And this block
       if (currentCharacterIndex === -1) {
          alert('No character selected to save.');
          return;
       }

       const char = characters[currentCharacterIndex];
       char.name = nameInput.value.trim() || 'Anon';
       char.color = colorInput.value || '#ffffff';
       char.avatarEmoji = currentAvatarEmoji;
       char.avatarImage = currentAvatarImage;
       char.side = currentSide;
 
       applyCharacterChangesToMessages(char);

      saveAll();
      renderCharacters();
      renderChat();
      alert('Character slot saved!');
    });
  }

  nameInput.addEventListener('input', (e) => {
    if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
      const char = characters[currentCharacterIndex];
      const newName = e.target.value;

      char.name = newName;
      applyCharacterChangesToMessages(char);

      
      saveAll();
      renderCharacters();
      renderChat();
    }
  });


  function adjustTextColor(bgColor) {
    // Convert hex to RGB
    const hex = bgColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    // Convert RGB to HSL
    const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
    const max = Math.max(rNorm, gNorm, bNorm), min = Math.min(rNorm, gNorm, bNorm);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0; // achromatic
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case rNorm: h = (gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0); break;
        case gNorm: h = (bNorm - rNorm) / d + 2; break;
        case bNorm: h = (rNorm - gNorm) / d + 4; break;
      }
      h /= 6;
    }

    // Adjust lightness ‚Äî slightly lighter if dark background, or slightly darker if light
    const tweak = 0.2;
    const newL = l > 0.5 ? l - tweak : l + tweak;

    // Convert HSL back to RGB
    let r2, g2, b2;
    if (s === 0) {
      r2 = g2 = b2 = newL; // achromatic
    } else {
      function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }
      const q = newL < 0.5 ? newL * (1 + s) : newL + s - newL * s;
      const p = 2 * newL - q;
      r2 = hue2rgb(p, q, h + 1/3);
      g2 = hue2rgb(p, q, h);
      b2 = hue2rgb(p, q, h - 1/3);
    }

    // Convert back to hex
    const toHex = x => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r2)}${toHex(g2)}${toHex(b2)}`;
  }

  // Get current timestamp HH:MM
  function getCurrentTime() {
    const now = new Date();
    return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  // Render chat messages
  function renderChat() {
  chatContainer.innerHTML = '';
  let lastDate = null;

  chatData.forEach((msg, index) => {
    const msgDate = new Date(msg.timestamp || Date.now());
    const msgDateStr = msgDate.toDateString(); // e.g., "Thu Aug 7 2025"

    // Insert date separator if date changed
    if (msgDateStr !== lastDate) {
      const dateDiv = document.createElement('div');
      dateDiv.style.textAlign = 'center';
      dateDiv.style.fontSize = '10px';
      dateDiv.style.color = '#aaa';
      dateDiv.style.margin = '10px 0';
      dateDiv.textContent = msgDate.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric',
        year: 'numeric',
      });
      chatContainer.appendChild(dateDiv);
      lastDate = msgDateStr;
    }

    const container = document.createElement('div');
    container.classList.add('chat-message-container');
    container.classList.add(msg.side);
    container.dataset.index = index;

    const header = document.createElement('div');
    header.classList.add('msg-header');

    const avatarDiv = document.createElement('div');
    avatarDiv.classList.add('avatar-header');

    if (msg.avatarImage) {
      const img = document.createElement('img');
      img.src = msg.avatarImage;
      avatarDiv.appendChild(img);
    } else {
      avatarDiv.textContent = msg.avatarEmoji || 'üôÇ';
    }

    const nameSpan = document.createElement('span');
    nameSpan.classList.add('name-header');
    nameSpan.textContent = msg.name;

    const timeSpan = document.createElement('span');
    timeSpan.classList.add('time-header');
    timeSpan.textContent = msg.time;

    header.appendChild(avatarDiv);
    header.appendChild(nameSpan);
    header.appendChild(timeSpan);

    const bubble = document.createElement('div');
    bubble.classList.add('bubble');
    bubble.classList.add(msg.side);
    bubble.style.backgroundColor = msg.color;
    bubble.style.color = adjustTextColor(msg.color);
    bubble.textContent = msg.message;

    // üí¨ Bubble click: Flip side and update character
    bubble.addEventListener('click', () => {
      // Flip message side
      const newSide = msg.side === 'left' ? 'right' : 'left';
      msg.side = newSide;

      // Try to match a character slot
      const matchedIndex = characters.findIndex(c => c.id === msg.characterId);

      if (matchedIndex !== -1) {
        currentCharacterIndex = matchedIndex;
        characters[matchedIndex].side = msg.side;
        currentSide = msg.side;
        updateCharacterInputs();
        renderCharacters();
      }


      // update messages to the new side
      chatData.forEach(m => {
  if (m.characterId === msg.characterId) {
    m.side = newSide;
  }
});


      saveAll();
      renderChat();
    });

    container.appendChild(header);
    container.appendChild(bubble);
    chatContainer.appendChild(container);
  });

  chatContainer.scrollTop = chatContainer.scrollHeight;
}

  // Save chatData and characters to localStorage
  function saveAll() {
    localStorage.setItem('chatData', JSON.stringify(chatData));
    localStorage.setItem('characters', JSON.stringify(characters));
  }

  // Render character circles
  function renderCharacters() {
    characterCircles.innerHTML = '';
    characters.forEach((char, i) => {
      const circle = document.createElement('div');
      circle.classList.add('char-circle');
      if (i === currentCharacterIndex) {
  circle.classList.add('selected');
  circle.style.backgroundColor = char.color || '#ddd';
  circle.style.color = adjustTextColor(char.color || '#ddd');
} else {
  circle.style.backgroundColor = '#ddd';
  circle.style.color = '#000';
}

      // Match bubble color
     circle.style.backgroundColor = char.color || '#ddd';
     circle.style.color = adjustTextColor(char.color || '#ddd');

      circle.title = char.name || 'Unnamed';

      const avatarDiv = document.createElement('div');
      avatarDiv.classList.add('char-avatar');

      if (char.avatarImage) {
        const img = document.createElement('img');
        img.src = char.avatarImage;
        avatarDiv.appendChild(img);
      } else if (char.avatarEmoji) {
        avatarDiv.textContent = char.avatarEmoji;
      } else {
        avatarDiv.textContent = 'üôÇ';
      }

      circle.appendChild(avatarDiv);
      circle.addEventListener('click', () => {
        currentCharacterIndex = i;
        updateCharacterInputs();
        renderCharacters();
      });
      characterCircles.appendChild(circle);
    });
  }

  // Update input controls to match current character
  function updateCharacterInputs() {
    if (currentCharacterIndex < 0 || currentCharacterIndex >= characters.length) {
      // If no characters, reset inputs
      nameInput.value = '';
      colorInput.value = '#ffffff';
      currentAvatarEmoji = 'üôÇ';
      currentAvatarImage = null;
      sideToggle.classList.remove('left');
      sideToggle.classList.add('right');
      currentSide = 'right';
      selectEmojiInPicker(currentAvatarEmoji);
      return;
    }
    const c = characters[currentCharacterIndex];
    nameInput.value = c.name || '';
    colorInput.value = c.color || '#ffffff';
    currentAvatarEmoji = c.avatarEmoji || 'üôÇ';
    currentAvatarImage = c.avatarImage || null;
    currentSide = c.side || 'right';

    if (currentSide === 'left') {
      sideToggle.classList.add('left');
      sideToggle.classList.remove('right');
    } else {
      sideToggle.classList.remove('left');
      sideToggle.classList.add('right');
    }

    selectEmojiInPicker(currentAvatarEmoji);
  }

  // Select emoji in avatar picker UI
  function selectEmojiInPicker(emoji) {
    const emojis = avatarPicker.querySelectorAll('.emojiOption');
    emojis.forEach(e => {
      if (e.textContent === emoji) {
        e.classList.add('selected');
      } else {
        e.classList.remove('selected');
      }
    });
  }

  // Send message function
  function sendMessage() {
    const msgText = messageInput.value.trim();
    if (!msgText) return alert('Please enter a message.');

    // Check character selected
    if (currentCharacterIndex === -1) {
      alert('Please add and select a character first.');
      return;
    }
    const char = characters[currentCharacterIndex];
    const name = nameInput.value.trim() || 'Anon';
    const color = colorInput.value || '#ffffff';
    const side = char.side;
    const avatarEmoji = currentAvatarEmoji;
    const avatarImage = currentAvatarImage;
    const time = getCurrentTime();

    // Save character info (in case changed inputs)
    char.name = name;
    char.color = color;
    char.side = side;
    char.avatarEmoji = avatarEmoji;
    char.avatarImage = avatarImage;
    
    // ‚úÖ Update all previous messages from this character
chatData.forEach(msg => {
  if (msg.characterId === char.id) {
    msg.name = char.name;
    msg.color = char.color;
    msg.side = char.side;
    msg.avatarEmoji = char.avatarEmoji;
    msg.avatarImage = char.avatarImage;
  }
});



    // Save chat message
    chatData.push({
      name: char.name,
      message: msgText,
      color: char.color,
      side: char.side,
      avatarEmoji:currentAvatarEmoji,
      avatarImage:currentAvatarImage,
      time:getCurrentTime(),
      timestamp: Date.now(),
      characterId: char.id,
    });

    // Save & render
    saveAll();
    renderChat();
    renderCharacters();

    messageInput.value = '';
    messageInput.focus();
  }

  // Clear chat
  clearBtn.addEventListener('click', () => {
    if (confirm('Clear all chat messages?')) {
      chatData = [];
      saveAll();
      renderChat();
    }
  });

  // Side toggle
  sideToggle.addEventListener('click', () => {
    if (currentSide === 'right') {
      currentSide = 'left';
      sideToggle.classList.add('left');
      sideToggle.classList.remove('right');
    } else {
      currentSide = 'right';
      sideToggle.classList.remove('left');
      sideToggle.classList.add('right');
    }
    if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
      const char = characters[currentCharacterIndex];
      characters[currentCharacterIndex].side = currentSide;
    
      applyCharacterChangesToMessages(char);


    saveAll();
    renderCharacters();
    renderChat();
    }
  });

  // Avatar picker emoji clicks
  avatarPicker.addEventListener('click', e => {
    if (e.target.classList.contains('emojiOption')) {
      currentAvatarEmoji = e.target.textContent;
      currentAvatarImage = null; // Clear uploaded avatar if any
      
      selectEmojiInPicker(currentAvatarEmoji);

      if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
        const char = characters[currentCharacterIndex]
        char.avatarEmoji = currentAvatarEmoji;
        char.avatarImage = null;

        applyCharacterChangesToMessages(char);

        saveAll();
        renderChat();
        renderCharacters();
      }
    }
  });

  // Upload avatar image button
  uploadAvatarBtn.addEventListener('click', () => {
    avatarFileInput.click();
  });

  // Upload avatar file input change
  avatarFileInput.addEventListener('change', () => {
    const file = avatarFileInput.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file.');
      return;
    }
    const reader = new FileReader();
    reader.onload = () => {
      currentAvatarImage = reader.result;
      currentAvatarEmoji = null;
      selectEmojiInPicker(null);

      if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
        characters[currentCharacterIndex].avatarImage = currentAvatarImage;
        characters[currentCharacterIndex].avatarEmoji = null;
        applyCharacterChangesToMessages(characters[currentCharacterIndex]);
        saveAll();
        renderChat();
        renderCharacters();
      }
    };
    reader.readAsDataURL(file);
  });

  // Name input change
  nameInput.addEventListener('input', () => {
    if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
      characters[currentCharacterIndex].name = nameInput.value.trim() || 'Anon';
      saveAll();
      renderCharacters();
    }
  });

  // Color input change
  colorInput.addEventListener('input', () => {
    if (currentCharacterIndex >= 0 && currentCharacterIndex < characters.length) {
      const char = characters[currentCharacterIndex];
      char.color = colorInput.value;
      applyCharacterChangesToMessages(char);
      r = colorInput.value;
      saveAll();
      renderChat();
      renderCharacters();
    }
  });

  // Add character button
  addCharacterBtn.addEventListener('click', () => {
    if (characters.length >= MAX_CHARACTERS) {
      alert('Maximum character limit reached.');
      return;
    }
    const newChar = {
      
      name: 'Anon',
      color: '#ffffff',
      avatarEmoji: 'üôÇ',
      avatarImage: null,
      side: 'right',
      id: Date.now() + Math.random(),
    };

    characters.push(newChar);
    currentCharacterIndex = characters.length - 1;
    updateCharacterInputs();
    saveAll();
    renderCharacters();
  });

  // Delete character button
  deleteCharacterBtn.addEventListener('click', () => {
    if (currentCharacterIndex === -1) {
      alert('No character selected to delete.');
      return;
    }
    if (!confirm(`Delete character "${characters[currentCharacterIndex].name}"?`)) return;

    characters.splice(currentCharacterIndex, 1);
    if (characters.length === 0) {
      currentCharacterIndex = -1;
    } else if (currentCharacterIndex >= characters.length) {
      currentCharacterIndex = characters.length - 1;
    }
    updateCharacterInputs();
    saveAll();
    renderCharacters();
  });

  // Send message on button click
  sendBtn.addEventListener('click', sendMessage);

  // Send message on Enter key (without Shift)
  messageInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  function applyCharacterChangesToMessages(char) {
  chatData.forEach(msg => {
    if (msg.characterId === char.id) {
      msg.name = char.name;
      msg.color = char.color;
      msg.side = char.side;
      msg.avatarEmoji = char.avatarEmoji;
      msg.avatarImage = char.avatarImage;
    }
  });
}
  // Initialize app
  function init() {
    // If no characters, add one by default
    if (characters.length === 0) {
      characters.push({
        name: 'Anon',
        color: '#ffffff',
        avatarEmoji: 'üôÇ',
        avatarImage: null,
        side: 'right',
      });
    }
    currentCharacterIndex = 0;
    updateCharacterInputs();
    renderChat();
    renderCharacters();
  }

  init();
});
</script>

</body>
</html>
